
#!/usr/bin/expect -f
# ASA check: run a command and return output, handling username/password and enable prompts
set timeout 40
if {$argc < 4} {
  puts "usage: asa_check_expect.exp host user password command"
  exit 2
}
set host [lindex $argv 0]
set user [lindex $argv 1]
set pass [lindex $argv 2]
set cmd  [lindex $argv 3]

# Coherent SSH options (force tty to handle ASA prompts)
set ssh_opts {-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedKeyTypes=+ssh-rsa -tt}
eval spawn ssh $ssh_opts $user@$host

# Generic handler for initial connection and auth
expect {
  -re "(?i)are you sure" { send "yes\r"; exp_continue }
  -re "(?i)username:" { send "$user\r"; exp_continue }
  -re "(?i)assword:" { send "$pass\r"; exp_continue }
  -re {#|>|%} { }
  timeout { puts STDERR "timeout connecting to $host"; exit 3 }
}

# If we're at '>' try to escalate to privileged mode
expect {
  -re ">" {
    send "enable\r"
    expect {
      -re "(?i)assword:" { send "$pass\r"; exp_continue }
      -re "# $" { }
      timeout { }
    }
  }
  -re "# $|% $" { }
  timeout { }
}

# Disable paging on ASA and run the requested command
send "terminal pager 0\r"
expect {
  -re {#|>|\(config\)#} { }
  timeout { }
}

send -- "$cmd\r"

# Collect command output until we see a prompt again or EOF
set out ""
expect {
  -re {#|>|\(config\)#} {
    append out $expect_out(buffer)
  }
  eof {
    append out $expect_out(buffer)
  }
  timeout { puts STDERR "timeout waiting for command"; exit 4 }
}

puts $out

# Return the remote exit/status if available
set s [wait]
set rc [lindex $s 3]
exit $rc
